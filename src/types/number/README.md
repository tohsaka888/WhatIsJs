# 数字类型

在现代 `JavaScript` 中，数字（number）有两种类型：

1. `JavaScript` 中的常规数字以 64 位的格式 `IEEE-754` 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。(相当于`c`中`double`)

2. `BigInt` 用于表示任意长度的整数。有时会需要它们，因为正如我们在前面的章节 数据类型 中提到的。由于仅在少数特殊领域才会用到 `BigInt` ，因此我们在特殊的章节 `BigInt` 中对其进行了介绍。

## toString(base)

方法 `num.toString(base)` 返回在给定 `base` 进制数字系统中 `num` 的字符串表示形式。

```javascript
let num = 255;

alert(num.toString(16)); // ff
alert(num.toString(2)); // 11111111
```

base 的范围可以从 `2` 到 `36`。默认情况下是 `10`。

```javascript
(123).toString();
```

> 使用两个点来调用一个方法, 。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 toString，那么我们需要在它后面放置两个点 ..。也可以写成 (123).toString()。

## 舍入

舍入（rounding）是使用数字时最常用的操作之一。

这里有几个对数字进行舍入的内建函数：

**`Math.floor`**

向下舍入：`3.1` 变成 `3`，`-1.1` 变成 `-2`。

**`Math.ceil`**
向上舍入：`3.1` 变成 `4`，`-1.1` 变成 `-1`。

**`Math.round`**
向最近的整数舍入：`3.1` 变成 `3`，`3.6` 变成 `4`，中间值 `3.5` 变成 `4`。(四舍五入到整数位)

**`Math.trunc`**
移除小数点后的所有内容而没有舍入：`3.1` 变成 `3`，`-1.1` 变成 `-1`。

这些函数涵盖了处理数字小数部分的所有可能方法。但是，如果我们想将数字舍入到小数点后 `n` 位，该怎么办？

1. 乘除法

例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100，调用舍入函数，然后再将其除回。

```javascript
let num = 1.23456;

alert(Math.round(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
```

2. 函数 `toFixed(n)` 将数字舍入到小数点后 `n` 位，并以字符串形式返回结果。(`toFixed`不是四舍五入)

```javascript
let num = 12.34;
alert(num.toFixed(5)); // "12.34000"，在结尾添加了 0，以达到小数点后五位
```

3. 封装一个函数(等同于 1)

```js
function round(number, precision) {
  return Math.round(+number + "e" + precision) / Math.pow(10, precision);
}

round(1.005, 2); //1.01
```

## 不精确的计算

在内部，数字是以 `64` 位格式 `IEEE-754` 表示的，所以正好有 `64` 位可以存储一个数字：其中 `52` 位被用于存储这些数字，其中 `11` 位用于存储小数点的位置，而 `1`位用于符号。

```js
console.log(0.1 + 0.2 == 0.3); // false
```

没错，如果我们检查 `0.1` 和 `0.2` 的总和是否为 `0.3`，我们会得到 `false`。

奇了怪了！如果不是 `0.3`，那能是啥？

```js
alert(0.1 + 0.2); // 0.30000000000000004
```

为什么会这样呢？

一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是**无限循环小数**。

在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 `2` 的**整数次幂**作为除数时能够正常工作，但 `1/10` 就变成了一个无限循环的二进制小数。

> 大白话解释就是: 以浮点数来说, 只有 2 的-n 次方的小数是可以准确存储的, 比如: 0.5(2 的-1 次方), 0.25(2 的-2 次方). 0.125(2 的-3 次方)......可以准确存储,而 0.1, 0.2, 0.3...这些则不可以

我们看下面这个例子:

```javascript
console.log((0.1).toFixed(20)); // 0.10000000000000000555
console.log((0.2).toFixed(20)); // 0.20000000000000001110
console.log((0.3).toFixed(20)); // 0.29999999999999998890

console.log((0.5).toFixed(20)); // 0.50000000000000000000 准确
console.log((0.25).toFixed(20)); // 0.25000000000000000000 准确
console.log((0.125).toFixed(20)); // 0.12500000000000000000 准确
```

我们能解决这个问题吗？当然，最简单的方法是借助方法 `toFixed(n)` 对结果进行舍入：

```js
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // "0.30"
```

> 但是`toFixed`不是四舍五入, 当需要保留多位小数时可能会有误差
> 推荐使用三方库: `bignumber.js`/ `decimal.js`

## 补充面试题

`0.1 + 0.2 === 0.3`的结果是什么?为什么?

这个上面已经解释的很清楚了!
