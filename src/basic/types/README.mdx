JavaScript 中的值都具有特定的类型。例如，字符串或数字。

在 JavaScript 中有 8 种基本的数据类型（7 种原始类型和 1 种引用类型）。

> 七种引用类型: `Number`, `String`, `BigInt`, `Symbol`, `Boolean`, `Null`, `Undefined`
> 一种引用类型: `Object`

## `typeof`判断数据类型

**语法:**

```js
typeof a;
//  or
typeof a;
```

**示例:**

```js
typeof undefined; // "undefined"

typeof 0; // "number"

typeof 10n; // "bigint"

typeof true; // "boolean"

typeof "foo"; // "string"

typeof Symbol("id"); // "symbol"

typeof Math; // "object"

typeof null; // "object"  (1)

typeof alert; // "function"  (2)
```

1. typeof null 的结果为 "object"。这是官方承认的 typeof 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。typeof 的行为在这里是错误的。
1. typeof alert 的结果是 "function",在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。但是 typeof 会对函数区分对待。

## `instanceof`判断数据类型

`instanceof` 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

> instanceof 不能判断基本数据类型

## 准确的类型判断 `Object.prototype.toString().call(...)`

每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。

```js
function judgeType(arg) {
  return Object.prototype.toString.call(arg).split(" ")[1].slice(0, -1).toLowerCase();
}
```

## 补充相关面试题

`typeof` 和 `instanceof` 的区别?

> `typeof`和`instanceof`都可以判断类型。`typeof`判断`null`时会输出`object`这是`JavaScript`内部实现错误。`instanceof`通过原型链判断类型, 因此`instanceof`不能判断基本数据类型。
> 如果需要进行准确的类型判断, 我们应该使用`Object.prototype.toString.call(...)`来进行判断。
